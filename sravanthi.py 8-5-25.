--------------1
# Find   outputs (Home  work)
from threading import *
import  time
def    disp():
	main_thread() . join(10)
	for  i  in  range(10):
		print('child  thread')
child = Thread(target = disp)
child . start()
for  i  in  range(10):
	print('main  thread')
	time . sleep(2)
OUTPUT:
main thread
main thread
main thread
main thread
main thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
main thread
main thread
main thread
main thread
main thread
-------------2
#  Find  outputs  (Home  work)
from threading import *
import time
def  disp():
	main_thread() . join()# child thread waits for mainthread to dead
	for  i  in  range(10):
		print('child  thread') 
child = Thread(target = disp)
child . start()
child . join()# main thread waits for child thread to dead
for  i  in  range(10):
	  print('main  thread')
output:
No output for this pgrm due to deadlock
------------3
'''
Modify  following  program  such  that   t1  should  execute  double()  function  and
t2  should  execute  square()  function
'''
from threading import *
import time
def   double():
	for   i  in  range(1 , 7):
		print('Double : ' , 2 * i)
		time . sleep(1)
def   square():
	for   i  in   range(1 , 7):
		print('Square : ' , i * i)
		time . sleep(1)
start = time . time()
double()
square()
end = time . time()
print('Execution  time  of  2 functions : ' , end - start)

from threading import *
import time
def double():
  for i in range(1,7):
      print('Double:',2*i)
      time.sleep(1)
def square():
  for i in range(1,7):
      print('Square:',i*i)
      time.sleep(1):
start=time.time()
t1= Thread(target=double)
t2= Thread(target=square)
t1.start()
t2.start()
t1.join()
t2.join()
end=time.time()
print('Execution time of 2 functions:',end-start)
OUTPUT:
Double:2
Square:1
Double:4
Square:4
Double:6
Square:9
Double:8
Square:16
Double:10
Square:25
Double:12
Square:36
Execution time of 2 functions:6.01
---------4
# Modify  following  program  such  that  final  balance  should  be  1300
from  threading  import  *
import  time
l = Lock()
class   Account:
	def  _init_(self , acno1 , bal1):
		self . acno = acno1
		self . bal = bal1
	def  credit(self , amt):
		s = current_thread() . name
		print(F'{s}  is  depositing  Rs. {amt}   into  account   {ac . acno}')
		x = self . bal
		time . sleep(1)
		self . bal = x + amt
ac = Account( 25 , 1000.0)
print('Initial  Balance :  ' , ac . bal )
t1 = Thread(target = ac . credit , name = 'Rama' , args = (100,))
t2 = Thread(target = ac . credit , name = 'Sita' , args = (200,))
t1 . start()
t2 . start()
t1 . join()
t2 . join()
print('Final balance :  ' , ac . bal)

from threading import *
import time
l=Lock()
class   Account:
	def  _init_(self , acno1 , bal1):
		self . acno = acno1
		self . bal = bal1
	def  credit(self , amt):
		s = current_thread() . name
		print(F'{s}  is  depositing  Rs. {amt}   into  account   {ac . acno}')
    l.acquire()
    try:
		   x = self . bal
		   time . sleep(1)
		   self . bal = x + amt
    finally:
        l.release()
ac = Account( 25 , 1000.0)
print('Initial  Balance :  ' , ac . bal )
t1 = Thread(target = ac . credit , name = 'Rama' , args = (100,))
t2 = Thread(target = ac . credit , name = 'Sita' , args = (200,))
t1 . start()
t2 . start()
t1 . join()
t2 . join()
print('Final balance :  ' , ac . bal)
OUTPUT:
Initial  Balance : 1000.0
Rama  is  depositing  Rs. 100   into  account  25
Sita is  depositing  Rs. 200 into  account  25
Final balance :  1300.0
------------5
#  Find  outputs (Home  work)
from threading import *
import time
def   f1():
        sem . acquire()
        name = current_thread() . name
        print(name , 'is   under   execution')
        time . sleep(1)
        print(name , 'finished  execution')
        sem . release()
sem = Semaphore(3)
t1 = Thread(target = f1 , name = 'One')
t2 = Thread(target = f1 , name = 'Two')
t3 = Thread(target = f1 , name = 'Three')
t4 = Thread(target = f1 , name = 'Four')
t5 = Thread(target = f1 , name = 'Five')
t6 = Thread(target = f1 , name = 'Six')
t7 = Thread(target = f1 , name = 'Seven')
t8 = Thread(target = f1 , name = 'Eight')
t9 = Thread(target = f1 , name = 'Nine')
t1 . start()
t2 . start()
t3 . start()
t4 . start()
t5 . start()
t6 . start()
t7 . start()
t8 . start()
t9 . start()
OUTPUT:
One is under execution
Two is under execution
Three is under execution
One finished execution
Four is under execution
Two finished execution
Five is under execution
Three finished execution
Six is under execution
Four finished execution
Seven is under execution
Five finished execution
Eight is under execution
Six finished execution
Nine is under execution
Seven finished execution
Eight finished execution
Nine finished execution
---------6
#  Find  outputs
from  threading  import *
import  time
def    fact(n):
	sem . acquire()  #  3
	if   n  >  0:
		x = n * fact(n - 1)
	else:
		x = 1
	sem . release()
	return   x
#end of the function
def    disp(n):
	print(n , ' != ' , fact(n))
sem = Semaphore(8)
t1 = Thread(target = disp , args = (4,))
t2 = Thread(target = disp , args = (7,))
t1 . start()
t2 . start()
OUTPUT:
4!= 24
7!= 5040
-------------7
#  Find  outputs  (Home  work)
from   queue   import  Queue
from  threading  import  *
q = Queue()
How  to  insert  10 , 20 , 30 , 40 , 50  into  object  'q'  with  for  loop
print('Deleted  elements')
How  to  remove  each  element  of  object  'q'  until  it  is  empty
print(active_count())
print(q . get())
print('End')
OUTPUT:
Deleted elements
10
20
30
40
50
1
End
------------8
#  Find  outputs  (Home  work)
from   queue  import  LifoQueue
stack = LifoQueue()
How  to  insert  10 , 20 , 30 , 40 , 50  into  stack  object  with  for  loop
print('Deleted  elements')
How  to  remove  each  element  of   stack  object   until  it  is  empty
print(stack . get())
print('End')
OUTPUT:
Deleted  elements
50
40
30
20
10
Stack is empty
End
-----------9
#  Find  outputs  (Home  work)
from   queue   import  PriorityQueue
pq = PriorityQueue()
How  to  insert  10 , 20 , 30 , 40 , 50  into  object  pq  with  for  loop
print('Deleted  elements')
How  to  remove  each  element  of  object  pq  until  it  is  empty
print(pq . get())
print('End')
OUTPUT:
Deleted  elements
10
20
30
40
50
End
----------10
from  queue  import  Queue
q = Queue()
q . put(('Hyd' , 10))
q . put(('Delhi' , 20))
q . put(('Chennai' , 15))
q . put(('Pune' , 5))
q . put(('Mumbai' , 12))
How  to  remove  each  tuple  of  object  'q'  until  it  is  empty(USING while loop)
from  queue  import  Queue
q = Queue()
q . put(('Hyd' , 10))
q . put(('Delhi' , 20))
q . put(('Chennai' , 15))
q . put(('Pune' , 5))
q . put(('Mumbai' , 12))
while not q.empty():
    print(q.get())
OUTPUT:
('Hyd' , 10)
('Delhi' , 20)
('Chennai' , 15)
('Pune' , 5)
('Mumbai' , 12)
--------11
#  Find  outputs  (Home  work)
from  queue  import   LifoQueue
stack = LifoQueue()
stack . put(('Hyd' , 10))
stack . put(('Delhi' , 20))
stack . put(('Chennai' , 15))
stack . put(('Pune' , 5))
stack . put(('Mumbai' , 12))
How  to  remove  each  tuple  of  stack  object  until  it  is  empty(USING while loop)
from  queue  import   LifoQueue
stack = LifoQueue()
stack . put(('Hyd' , 10))
stack . put(('Delhi' , 20))
stack . put(('Chennai' , 15))
stack . put(('Pune' , 5))
stack . put(('Mumbai' , 12))
while not stack.empty():
    print(stack.get())
OUTPUT:
('Mumbai' , 12)
('Pune' , 5)
('Chennai' , 15)
('Delhi' , 20)
('Hyd' , 10)
--------12
#  Find  outputs
from  queue  import   PriorityQueue
pq = PriorityQueue()
pq . put(('Hyd' , 10))
pq . put(('Delhi' , 20))
pq . put(('Chennai' , 15))
pq . put(('Pune' , 5))
pq . put(('Mumbai' , 12))
How  to  remove  each  tuple  of  object  pq  until  it  is  empty
from  queue  import   PriorityQueue
pq = PriorityQueue()
pq . put(('Hyd' , 10))
pq . put(('Delhi' , 20))
pq . put(('Chennai' , 15))
pq . put(('Pune' , 5))
pq . put(('Mumbai' , 12))
while not pq.empty():
   print(pq.get())
OUTPUT:
('Chennai' , 15)
('Delhi' , 20)
('Hyd' , 10)
('Mumbai' , 12)
('Pune' , 5)
-----------13
# Find  outputs
from  queue  import   PriorityQueue
pq = PriorityQueue()
pq . put(('Hyd' , 10))
pq . put(('Hyd' , 20))
pq . put(('Hyd' , 15))
pq . put(('Hyd' , 5))
pq . put(('Hyd' , 12))
print('Deleted tuples')
How  to  remove  each  tuple  of  object  pq  until  it  is  empty
from  queue  import   PriorityQueue
pq = PriorityQueue()
pq . put(('Hyd' , 10))
pq . put(('Hyd' , 20))
pq . put(('Hyd' , 15))
pq . put(('Hyd' , 5))
pq . put(('Hyd' , 12))
while not pq.empty():
   print(pq.get())
OUTPUT:
('Hyd' , 5)
('Hyd' , 10)
('Hyd' , 12)
('Hyd' , 15)
('Hyd' , 20)






























