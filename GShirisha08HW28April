#Find outputs
class father:
	def m1(self):
		print('m1 method of Father class')
class mother:
	def m1(self):
		print('m1 method of Mother class')
class uncle:
	def m1(self):
		print('m1 method of Uncle class')
class child(father, mother, uncle):
	def m1(self):
		print('m1 method of child class')
		super().m1()
		super(child,child()).m1()
		m=mother()
		m.m1()
		u=uncle()
		u.m1()
print(child.__mro__)
c=child()
c.m1()
print('Bye')

#Outputs
(<class '__main__.child'>, <class '__main__.father'>, <class '__main__.mother'>, <class '__main__.uncle'>, <class 'object'>)
m1 method of child class
m1 method of Father class
m1 method of Father class
m1 method of Mother class
m1 method of Uncle class
Bye



#Find outputs
class A:
	def m1(self):
		super().m1()
		print('class A method')
class B:
	def m1(self):
		super().m1()
		print('class B method')
class C:
	def m1(self):
		super().m1()
		print('class C method')
class D:
	def m1(self):
		#super().m1() #Error : Object class has no m1 method
		print('class D object')
class X(A,B):
	def m1(self):
		super().m1()
		print('class X method')
class Y(B,C,D):
	def m1(self):
		super().m1()
		print('class Y method')
class P(X,Y,C):
	def m1(self):
		super().m1()
		print('class P method')
print(P.mro())
obj=P()
obj.m1()
print('Bye')

#Outputs
P.mro()=P+merge(X,Y,C)
       =P+merge(XABO,YBCDO,CO)
       =P+X+merge(ABO,YBCDO,CO)
	   =P+X+A+merge(BO,YBCDO,CO)
	   =P+X+A+Y+merge(BO,BCDO,CO)
	   =P+X+A+Y+B+merge(O,CDO,CO)
	   =P+X+A+Y+B+C+merge(O,DO,O)
	   =P+X+A+Y+B+C+D+merge(O,O,O)
	   =P+X+A+Y+B+C+D+O
class D object
class C object
class B object
class Y object
class A object
class X object
class P object
Bye



#Find outputs
class D:
	def __init__(self):
		super().__init__()
		print('class D constructor')
class E:
	def __init__(self):
		super().__init__()
		print('class E constructor')
class F:
	def __init__(self):
		super().__init__()
		print('class F constructor')
class B(D,E):
	def __init__(self):
		super().__init__()
		print('class B constructor')
class C(D,E,F):
	def __init__(self):
		super().__init__()
		print('class C constructor')
class A(B,C):
	def __init__(self):
		super().__init__()
		print('class A constructor')
print(A.mro())
obj=A()
print('Bye')

#Outputs
A.mro()=A+merge(BDEO,CDEFO)
	   =A+B+merge(DEO,CDEFO)
	   =A+B+C+merge(DEO,DEFO)
	   =A+B+C+D+merge(EO,EFO)
	   =A+B+C+D+E+merge(O,FO)
	   =A+B+C+D+E+F+merge(O,O)
	   =A+B+C+D+E+F+O
class F constructor
class E constructor
class D constructor
class C constructor
class B constructor
class A constructor
Bye



#Identify error
class c1(c1): #parent c1 class is not defined
	pass



#Find outputs
class c1:
	def m1(self):
		print('Parent Method')
class c1(c1):
	def m1(self):
		super().m1()   #Parent Method
		print('Child Method') #Child Method
a=c1()
a.m1() 



#Identify Error
class c1(c2): #Error : c2 is not defined
	pass
class c2(c1):
	pass



#Find outputs
class c2:
	def m1(self):
		print('Parent Method')
class c1(c2):
	def m1(self):
		super().m1()
		print('Child Method')
class c2(c1):
	def m1(self):
		super().m1()
		print('Grand Child Method')
a=c2()
a.m1()

#Outputs
Parent Method
Child Method
Grand Child Method



#Find outputs
class parent:
	def m1(self):
		print('Overridden Method')
class child(parent):
	def m1(self):
		print('Overriding Method')
x=parent()
x.m1() #Overridden Method
x=child()
x.m1() #Overriding Method



#Find outputs
class parent:
	def m1(self):
		print('m1 method of parent class')
	def m2(self):
		print('m2 method of parent class')
class child(parent):
	def m1(self):
		print('m1 method of child class')
	def m3(self):
		print('m3 method of child class')
x=parent()
x.m1()  #m1 method of parent class
x.m2()  #m2 method of parent class
#x.m3()  #Error : no m3 method in parent class
x=child()
x.m1()  #m1 method of child class
x.m2()  #m2 method of parent class
x.m3()  #m3 method of child class



#Find outputs
class parent:
	def marriage(self):
		print('Arrange Marriage')
	def property(self):
		print('One Crore')
	def study(self):
		print('Studies only',end='\t')
class child(parent):
	def marriage(self):
		print('Love Marriage')
	def study(self):
		super().study()
		print('+Entertainment')
c=child()
c.marriage()
c.property()
c.study()

#Outputs
Love Marriage
One Crore
Studies only    +Entertainment



#Find outputs
class parent:
	def add(self,x,y):
		return x+y
class child(parent):
	def add(self,x,y,z):
		return x+y+z
c=child()
print(c.add(10,20,30)) #60
print(c.add(10,20))    #Error : no arg for z



#Find outputs
class parent:
	def add(self,x,y):
		print('parent method')
		return x+y
class child(parent):
	def add(self,x,y,z=3):
		print('child method')
		return x+y+z
c=child()
print(c.add(10,20,30)) #parent method <\n> 60
print(c.add(10,20))    #child method <\n> 33



#Find outputs
class parent:
	def m1(self,a,b,/):
		print(F'parent method a : {a} \t b : {b}')
class child(parent):
	def m1(self,x,y):
		print(F'child method x : {x} \t y : {y}')
c=child()
c.m1(x=10, y=20)
c.m1(30,40)

#Outputs
child method x : 10      y : 20
child method x : 30      y : 40



#Find outputs
from abc import *
class c1(ABC):
	@abstractmethod
	def m1(self):
		pass
	def __init__(slef):
		print('c1 class constructor')
class c2(ABC):
	def m1(self):
		pass
	def __init__(slef):
		print('c2 class constructor')
class c3:
	@abstractmethod
	def m1(self):
		pass
	def __init__(slef):
		print('c3 class constructor')
class c4(c1):
	def m1(self):
		pass
	def __init__(slef):
		print('c4 class constructor')
class c5(c1):
	def __init__(slef):
		print('c1 class constructor')
c1() #Invalid : abstract class with abstract method m1
c2() #Valid (no abstract method)
c3() #Valid (not a abstract class)
c4() #Invalid : abstract class with abstract method m1
c5() #Invalid : abstract class with abstract method m1



#Write  a  program  to  determine  area  and  perimeter  of  triangle , circle , rectangle  and  square
import math
from abc import  *
class shape(ABC):
	def get(self):
		self.a=float(input()) #How  to  read  input  to  variable  'a'  of  object  self
	@abstractmethod
	def area(self):
		pass
	@abstractmethod
	def peri(self):
		pass
	@abstractmethod
	def test(self):
		pass
class triangle(shape):
	def get(self):
		print('Enter 3 sides of triangle')
		#How  to  read  the  3  sides  of  triangle
		super().get()
		self.b=float(input())
		self.c=float(input())
	def area(self):
		s=(self.a+self.b+self.c)/2
		return math.sqrt(s*(s-self.a)*(s-self.b)*(s-self.c)) #area  of  triangle
	def peri(self):
		return self.a+self.b+self.c #perimeter  of  triangle
	def test(self):
		if self.a+self.b>=self.c or self.b+self.c>=self.a or self.c+self.a>=self.b: #sum  of  every  2  sides  should  be  >   3rd   side
				pass #do  nothing
		else:
			print('Not a triangle')
			exit() #How  to  stop  execution
class circle(shape):
	def get(self):
		print('Enter radius of circle :', end=' ')
		super().get() #How  to  read  radius
	def area(self):
		return math.pi*self.a**2 #area  of  circle
	def peri(self):
		return 2*math.pi*self.a #circumference  of circle
	def test(self):
		if self.a<0: #side  is  -ve
		    print('Radius can not be -ve')
		    exit() #How  to  stop  execution
class rectangle(shape):
	def get(self):
		print('Enter length and breadth of rectangle')
		#How  to  read  length  and  breadth
		super().get() 
		self.b=float(input())
	def area(self):
		return self.a*self.b  #area  of  rectangle
	def peri(self):
		return 2*(self.a+self.b) #perimeter  of  triangle
	def test(self):
		if self.a==self.b: #length  and   breadth  same
		    print('Not a rectangle')
		    exit() #How  to  stop  execution
class square(shape):
	def get(self):
		print('Enter any side of square :', end=' ')
		super().get() #How  to  read  side
	def area(self):
		return self.a**2 #area  of  square
	def peri(self):
		return 4*self.a #perimeter  of  square
	def test(self):
		pass
#End of the class
def menu():
	print('1. Triangle')
	print('2. Circle')
	print('3. Rectangle')
	print('4. Square')
	print('5. Exit')
#End of menu function
def operation(s):
	s.get() #How  to  read  inputs  to  object  's'
	s.test() #How  to  test  inputs  are  valid  (or)  not
	print('Area :',s.area())
	print('Perimeter :', s.peri());
# End  of  the  function
menu()
ch=eval(input('Enter choice : '))
while ch!=5: #repeat  until  user  input  is  5
	match ch:
		case 1:
			t=triangle()
			operation(t)  #How  to  call  operation()  function
		case 2:
			c=circle()
			operation(c) #How  to  call  operation()  function
		case 3:
			r=rectangle()
			operation(r) #How  to  call  operation()  function
		case 4:
			s=square()
			operation(s) #How  to  call  operation()  function
	#end of match
	menu()
	ch=int(input('Enterchoice : '))
#End of while loop
print('Good Bye')

#Output
1. Triangle
2. Circle
3. Rectangle
4. Square
5. Exit
Enter choice : 1
Enter 3 sides of triangle
3
4
5
Area : 6.0
Perimeter : 12.0
1. Triangle
2. Circle
3. Rectangle
4. Square
5. Exit
Enterchoice : 2
Enter radius of circle : 4
Area : 50.26548245743669
Perimeter : 25.132741228718345
1. Triangle
2. Circle
3. Rectangle
4. Square
5. Exit
Enterchoice : 3
Enter length and breadth of rectangle
4
5
Area : 20.0
Perimeter : 18.0
1. Triangle
2. Circle
3. Rectangle
4. Square
5. Exit
Enterchoice : 4
Enter any side of square : 4
Area : 16.0
Perimeter : 16.0
1. Triangle
2. Circle
3. Rectangle
4. Square
5. Exit
Enterchoice : 5
Good Bye




#Find outputs
from abc import *
class parent(ABC):
	@abstractmethod
	def m1(self):
		pass
	@abstractmethod
	def m2(self):
		pass
	@abstractmethod
	def m3(self):
		pass
class child(parent):
	def m1(self):
		print('m1 method of child class')
class gc(child):
	def m2(self):
		print('m2 method of gc class')
class ggc(gc):
	def m3(self):
		print('m3 method of ggc class')
a=ggc()
a.m1() #m1 method of child class
a.m2() #m2 method of gc class
a.m3() #m3 method of ggc class
parent() #Error : abstract class with 3 abstract method
child()  #Error : abstract class with 2 abstract method
gc()     #Error : abstract class with 1 abstract method
